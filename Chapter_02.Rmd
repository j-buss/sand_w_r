---
title: "Chapter 02"
output: html_document
date: '2023-06-02'
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
# SAND with R, chapter2.tex
```{r}
library(igraph)
library(sand)
```

Create an undirected toy graph.
```{r}
g <- graph_from_literal(1-2, 1-3, 2-3, 2-4, 3-5, 4-5, 
                    4-6, 4-7, 5-6, 6-7)
```

How many vertices in the graph "g"? And show their names
```{r}
V(g)
```

How many edges in the graph "g"? Display the edges with their vertex names.
```{r}
E(g)
```

Print all the information about the graph: 2 ways
1.
```{r}
print_all(g)
```
2.
```{r}
str(g)
```

Show the graph
```{r}
plot(g)
```

Create a Directed Graph:
```{r}
dg <- graph_from_literal(1-+2, 1-+3, 2++3)
```

Show the Directed graph:
```{r}
plot(dg)
```


Create a directed graph with named vertices:
```{r}
dg <- graph_from_literal(Sam-+Mary, Sam-+Tom, 
                          Mary++Tom)
```
Another way to create graph with named vertices:
```{r}
dg2 <- graph.formula(Sam-+Mary, Sam-+Tom, 
                          Mary++Tom)
```

Print the directed graph information
```{r}
print_all(dg)
```

```{r}
V(dg)
```
Change/assign the names of the vertices

```{r}
V(dg)$name <- c("Sam", "Mary", "Tom")
```

Edges of the directed graph
```{r}
E(dg)
```
List the edges in list format, 2 columns with vertices
```{r}
get.edgelist(dg)
```

Show the Adjacency matrix:

```{r}
as_adjacency_matrix(g)
```

Create a subgraph a few different ways:
1. Subgraph from vertices 1 - 5
```{r}
h <- induced_subgraph(g, 1:5)
```

```{r}
print_all(h)
```

2. Subgraph from subtracting out two vertices
```{r}
h <- g - vertices(c(6,7))
```

The full graph can then be recreated in a few similar ways as well:
1. Take the subgraph, add back in two vertices; then add back in the 4 edges
```{r}
h <- h + vertices(c(6,7))
g <- h + edges(c(4,6),c(4,7),c(5,6),c(6,7))
```

2. Take the union of two subgraphs
```{r}
h1 <- h
h2 <- graph_from_literal(4-6, 4-7, 5-6, 6-7)
g <- union(h1,h2)
```

Recall our named vertices previously.
Name was just an attribute of the vertices. We can add other attributes as well:

```{r}
V(dg)$name
```

```{r}
V(dg)$gender <- c("M","F","M")
```

Print the gender attributes
```{r}
V(dg)$gender
```

```{r}
print_all(dg)
```

Assign the color attribute to all the vertices of the graph "g"
```{r}
V(g)$color <- "red"
```

Check if a graph is weighted
```{r}
is_weighted(g)
```
Create a weighted graph. First assign our toy graph "g" to a new variable "wg"
```{r}
wg <- g
```

Return the number of edges on the graph:
```{r}
ecount(wg)
```

Use the Random Uniform Distribution to generate numbers to be used as weights
```{r}
runif(10)
```

Putting all the previous steps together and assigning the weights as attributed of the Edges of "wg"
```{r}
E(wg)$weight <- runif(ecount(wg))
is_weighted(wg)
```

Name the graph
```{r}
g$name <- "Toy Graph"
```

The Lazega network dataset comes from the SAND library and shows the interactions among a set of lawyers.
```{r}
elist.lazega
```
```{r}
v.attr.lazega
```
create the g.lazega graph from the elist.lazega with the vertices attributes from v.attr.lazega
```{r}
g.lazega <- graph_from_data_frame(elist.lazega,
                                   directed="FALSE",
                                   vertices=v.attr.lazega)
```

Name the lazega graph
```{r}
g.lazega$name <- "Lazega Lawyers"
```

How many vertices are there in the graph?
```{r}
vcount(g.lazega)
```

How many edges are there in the lazega graph?
```{r}
ecount(g.lazega)
```

List the attribute names in the lazega graph (these were loaded when we used the "vertices=v.attr.lazega" call when building the graph)

```{r}
vertex_attr_names(g.lazega)
```

If a graph has "loops" or "multi-edges" then the graph is called a "multi-graph". If the graph does not have either of these features it is called a simple graph. We can check for a simple graph very easily:
```{r}
is_simple(g)
```

We can create a copy of g and add a "multi-edge" to it.
```{r}
mg <- g + edge(2,3)
print_all(mg)
```

With the addition of the multi-edge the graph is no longer simple:
```{r}
is_simple(mg)
```

Make this "multi-graph" simple. 
1. Add a weight of 1 to each edge
2. Use the simplify() function which by default removes loops and multi-edges and then combines attributes as directed. Default it simply adds the weights.

```{r}
E(mg)$weight <- 1
wg2 <- simplify(mg)
is_simple(wg2)
```

```{r}
print_all(wg2)
```
Examine the weights of the edges
```{r}
E(wg2)$weight
```

Neighbor vertices are connected by an edge. List the neighbors of vertex 5
```{r}
neighbors(g,5)
```

2 edges are adjacent if joined by a common endpoint. A vertex is incident on an edge if it is the endpoint of the edge. So the number of edges incident on a vertex is referred to as degree:
```{r}
degree(g)
```

For directed graphs there is an in degree and an out degree
```{r}
degree(dg, mode="in")
```

```{r}
degree(dg, mode="out")
```


Is every vertex of the graph reachable?
```{r}
is_connected(g)
```

How many components does the graph have?
```{r}
clusters(g)
```
For directed graphs there are two types of connectedness.
1. Weakly connected if the graph is connected after removing the directedness from the edges (basically making it un directed)
2. Strongly - if every vertex is reachable from every other vertex using the directions
```{r}
is_connected(dg,mode="weak")
```

```{r}
is_connected(dg,mode="strong")
```

```{r}
diameter(g, weights=NA)
```

```{r}
g.full <- make_full_graph(7)
g.ring <- make_ring(7)
g.tree <- make_tree(9, children=2, mode="undirected")
g.star <- make_star(7, mode="undirected")
par(mfrow=c(2, 2), mai = c(0.2, 0.2, 0.2, 0.2))
plot(g.full)
plot(g.ring)
plot(g.tree)
plot(g.star)
```

```{r}
is_dag(dg)
```


```{r}
g.bip <- graph_from_literal(actor1:actor2:actor3,
   movie1:movie2, actor1:actor2 - movie1,
   actor2:actor3 - movie2)
V(g.bip)$type <- grepl("^movie", V(g.bip)$name)
print_all(g.bip, v=T)
```
```{r}
proj <- bipartite_projection(g.bip)
print_all(proj[[1]])
```
```{r}
print_all(proj[[2]])
```
